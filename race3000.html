<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Race to 3000</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="page-3000">
  <video class="bg-video-3000" autoplay muted loop playsinline>
    <source src="https://res.cloudinary.com/dj92eb97f/video/upload/v1766972500/3000_studios_back_dop_nldai9.mp4" type="video/mp4" />
  </video>
  <div class="scrim-3000"></div>

  <div class="race-shell">
    <h1>Race to 3000</h1>
    <div class="race-hud">
      <div>
        <label class="form-label">Enter your code (daughter / son / mom / dad)</label>
        <div class="button-row">
          <input id="login-code" type="password" placeholder="Enter code" />
          <button class="primary" id="login-btn">Start Turn</button>
        </div>
        <p class="muted" id="race-status">Login to begin.</p>
      </div>
      <div class="race-scores" id="race-scores"></div>
      <div>
        <p class="muted">Turns left: <span id="turns-left">0</span></p>
        <p class="muted">Current: <span id="current-player">â€”</span></p>
      </div>
    </div>

    <div class="race-grid" id="race-grid" aria-label="Match grid"></div>

    <div class="race-hud">
      <div class="race-card">
        <strong>Messages</strong>
        <div id="race-messages" class="muted"></div>
      </div>
    </div>
  </div>

  <script type="module" src="/nav.js"></script>
  <script>
    const GRID_WIDTH = 9;
    const GRID_HEIGHT = 15;
    const PIECES = ["ðŸŽ®", "ðŸ§¹", "ðŸ§½", "ðŸ”Œ", "ðŸ“±", "ðŸ’…", "ðŸ’»", "ðŸšš", "ðŸ”Š", "ðŸ› ï¸"];
    const WIN_SCORE = 3000;
    const TURNS_PER_PLAYER = 20;
    const PLAYERS = [
      { name: "Jerica", code: "daughter", color: "#FF1493" },
      { name: "Jadon", code: "son", color: "#00BFFF" },
      { name: "Mom", code: "mom", color: "#9370DB" },
      { name: "Dad", code: "dad", color: "#32CD32" },
    ];

    const gridEl = document.getElementById("race-grid");
    const loginBtn = document.getElementById("login-btn");
    const codeInput = document.getElementById("login-code");
    const statusEl = document.getElementById("race-status");
    const scoresEl = document.getElementById("race-scores");
    const turnsEl = document.getElementById("turns-left");
    const currentEl = document.getElementById("current-player");
    const messagesEl = document.getElementById("race-messages");

    let grid = [];
    let selected = null;
    let currentPlayer = null;
    let turnsLeft = 0;
    const scores = {};
    PLAYERS.forEach((p) => (scores[p.name] = 0));

    const clickSound = (f = 440) => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = f;
        gain.gain.value = 0.08;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.08);
      } catch (_) {}
    };

    const renderScores = () => {
      scoresEl.innerHTML = "";
      PLAYERS.forEach((p) => {
        const card = document.createElement("div");
        card.className = "race-card";
        card.style.borderColor = p.color;
        card.innerHTML = `<div style="color:${p.color};font-weight:700;">${p.name}</div><div class="muted">Score: ${scores[p.name] || 0}</div>`;
        scoresEl.appendChild(card);
      });
    };

    const createGrid = () => {
      const g = [];
      for (let y = 0; y < GRID_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < GRID_WIDTH; x++) {
          row.push(PIECES[Math.floor(Math.random() * PIECES.length)]);
        }
        g.push(row);
      }
      return g;
    };

    const drawGrid = () => {
      gridEl.innerHTML = "";
      grid.forEach((row, y) => {
        row.forEach((piece, x) => {
          const cell = document.createElement("div");
          cell.className = "race-cell";
          if (selected && selected.x === x && selected.y === y) cell.classList.add("selected");
          cell.textContent = piece;
          cell.addEventListener("click", () => handleCellClick(x, y));
          gridEl.appendChild(cell);
        });
      });
    };

    const findMatches = (g) => {
      const matches = [];
      // rows
      for (let y = 0; y < GRID_HEIGHT; y++) {
        let run = 1;
        for (let x = 1; x <= GRID_WIDTH; x++) {
          if (x < GRID_WIDTH && g[y][x] === g[y][x - 1]) run++;
          else {
            if (run >= 3) {
              for (let i = 0; i < run; i++) matches.push({ x: x - 1 - i, y });
            }
            run = 1;
          }
        }
      }
      // cols
      for (let x = 0; x < GRID_WIDTH; x++) {
        let run = 1;
        for (let y = 1; y <= GRID_HEIGHT; y++) {
          if (y < GRID_HEIGHT && g[y][x] === g[y - 1][x]) run++;
          else {
            if (run >= 3) {
              for (let i = 0; i < run; i++) matches.push({ x, y: y - 1 - i });
            }
            run = 1;
          }
        }
      }
      return matches;
    };

    const removeMatches = (g, matches) => {
      const copy = g.map((row) => [...row]);
      matches.forEach(({ x, y }) => (copy[y][x] = null));
      return copy;
    };

    const applyGravity = (g) => {
      for (let x = 0; x < GRID_WIDTH; x++) {
        let write = GRID_HEIGHT - 1;
        for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
          if (g[y][x] !== null) {
            g[write][x] = g[y][x];
            if (write !== y) g[y][x] = null;
            write--;
          }
        }
        for (let y = write; y >= 0; y--) {
          g[y][x] = PIECES[Math.floor(Math.random() * PIECES.length)];
        }
      }
      return g;
    };

    const processMatches = (g) => {
      let temp = g;
      let total = 0;
      let guard = 0;
      while (guard < 10) {
        const matches = findMatches(temp);
        if (!matches.length) break;
        total += matches.length * 10;
        temp = applyGravity(removeMatches(temp, matches));
        guard++;
      }
      grid = temp;
      if (total && currentPlayer) {
        scores[currentPlayer.name] = (scores[currentPlayer.name] || 0) + total;
        addMessage(`${currentPlayer.name} scored ${total} points!`);
      }
      renderScores();
      checkWinner();
    };

    const swapCells = (a, b) => {
      const temp = grid[a.y][a.x];
      grid[a.y][a.x] = grid[b.y][b.x];
      grid[b.y][b.x] = temp;
    };

    const handleCellClick = (x, y) => {
      if (!currentPlayer || turnsLeft <= 0) return;
      if (!selected) {
        selected = { x, y };
        clickSound(520);
        drawGrid();
        return;
      }
      const dx = Math.abs(selected.x - x);
      const dy = Math.abs(selected.y - y);
      if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
        swapCells(selected, { x, y });
        selected = null;
        turnsLeft--;
        turnsEl.textContent = turnsLeft;
        clickSound(360);
        processMatches(grid);
        drawGrid();
        if (turnsLeft <= 0) endTurn();
      } else {
        selected = { x, y };
        drawGrid();
      }
    };

    const addMessage = (msg) => {
      const span = document.createElement("div");
      span.textContent = msg;
      messagesEl.appendChild(span);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    };

    const checkWinner = () => {
      const winner = Object.entries(scores).find(([_, score]) => score >= WIN_SCORE);
      if (winner) {
        statusEl.textContent = `${winner[0]} wins!`;
        currentPlayer = null;
        turnsLeft = 0;
        turnsEl.textContent = turnsLeft;
      }
    };

    const endTurn = () => {
      addMessage(`${currentPlayer?.name} finished their turn.`);
      currentPlayer = null;
      turnsLeft = 0;
      turnsEl.textContent = turnsLeft;
      currentEl.textContent = "â€”";
      statusEl.textContent = "Login to continue.";
    };

    const login = () => {
      const code = codeInput.value.trim().toLowerCase();
      const player = PLAYERS.find((p) => p.code === code);
      if (!player) {
        statusEl.textContent = "Invalid code.";
        clickSound(220);
        return;
      }
      currentPlayer = player;
      turnsLeft = TURNS_PER_PLAYER;
      turnsEl.textContent = turnsLeft;
      currentEl.textContent = player.name;
      statusEl.textContent = `${player.name} turn started.`;
      grid = createGrid();
      selected = null;
      drawGrid();
      clickSound(660);
    };

    loginBtn.addEventListener("click", login);
    codeInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") login();
    });

    renderScores();
    drawGrid();
  </script>
</body>
</html>
